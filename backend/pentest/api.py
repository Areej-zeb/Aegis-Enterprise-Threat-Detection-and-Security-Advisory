import uuid
import logging
from fastapi import APIRouter, BackgroundTasks, HTTPException
from pydantic import BaseModel
from datetime import datetime

# Local imports
# Adjust relative imports based on how the app is run. 
# If running as module backend.ids.serve.app, we need absolute or relative to that context?
# Actually app.py does sys.path insert. 
# We'll stick to relative imports within the module.
# Local imports
from .scanner_engine import DockerNmapScanner
from .parsers import parse_nmap_xml
from .matcher import VulnerabilityMatcher, RiskScorer

router = APIRouter(prefix="/api/pentest", tags=["Pentest"])
logger = logging.getLogger(__name__)

# In-memory storage for now (will replace with DB in Phase 6)
SCAN_RESULTS = {}

class ScanRequest(BaseModel):
    target: str
    scan_type: str = "quick" # quick, full, stealth

class ScanResponse(BaseModel):
    scan_id: str
    status: str

# Global Matcher Instance
_matcher = None

def get_matcher():
    global _matcher
    if _matcher is None:
        logger.info("Initializing Vulnerability Matcher...")
        try:
            _matcher = VulnerabilityMatcher()
        except Exception as e:
            logger.error(f"Failed to init matcher: {e}")
    return _matcher

def run_background_scan(scan_id: str, target: str, scan_type: str):
    """
    Background task to execute the scan engine.
    """
    logger.info(f"Starting background scan {scan_id} for {target}")
    SCAN_RESULTS[scan_id]["status"] = "running"
    try:
        # Blocks until docker container finishes
        raw_xml = DockerNmapScanner.run_scan(target, scan_type)
        
        # Parse output
        parsed_result = parse_nmap_xml(raw_xml)
        
        # Enrichment: Vulnerability Matching
        matcher = get_matcher()
        if matcher:
            for host in parsed_result.get("hosts", []):
                for port in host.get("ports", []):
                    # Prefer product name (e.g. "vsftpd"), fallback to service name ("ftp")
                    product = port.get("product") 
                    service = port.get("service")
                    query = product if product else service
                    version = port.get("version")
                    
                    if query:
                        vulns = matcher.match(query, version)
                        # Serialize and Score
                        enriched_vulns = []
                        for v in vulns:
                            # Recalculate dynamic score based on current context
                            v.severity_score = RiskScorer.calculate(v)
                            enriched_vulns.append(v.dict(exclude_none=True))
                            
                        port["vulnerabilities"] = enriched_vulns
                        
                        # Add high-level summary to port
                        if enriched_vulns:
                            max_score = max(v["severity_score"] for v in enriched_vulns)
                            port["risk_score"] = max_score
                            port["vuln_count"] = len(enriched_vulns)
        
        SCAN_RESULTS[scan_id]["status"] = "completed"
        SCAN_RESULTS[scan_id]["completed_at"] = datetime.now().isoformat()
        SCAN_RESULTS[scan_id]["result"] = parsed_result
        logger.info(f"Scan {scan_id} completed successfully")
        
    except Exception as e:
        logger.error(f"Scan {scan_id} failed: {e}")
        SCAN_RESULTS[scan_id]["status"] = "failed"
        SCAN_RESULTS[scan_id]["error"] = str(e)

@router.post("/scan", response_model=ScanResponse)
async def start_scan(request: ScanRequest, background_tasks: BackgroundTasks):
    """
    Trigger a new pentest scan.
    """
    scan_id = str(uuid.uuid4())
    
    # Sanitize target (remove protocol if present)
    clean_target = request.target.replace("http://", "").replace("https://", "").rstrip("/")
    
    SCAN_RESULTS[scan_id] = {
        "id": scan_id,
        "target": clean_target,
        "type": request.scan_type,
        "status": "pending",
        "created_at": datetime.now().isoformat()
    }
    
    background_tasks.add_task(run_background_scan, scan_id, clean_target, request.scan_type)
    
    return {"scan_id": scan_id, "status": "pending"}

@router.get("/results/{scan_id}")
async def get_scan_results(scan_id: str):
    """
    Get the status/results of a specific scan.
    """
    if scan_id not in SCAN_RESULTS:
        raise HTTPException(status_code=404, detail="Scan not found")
    return SCAN_RESULTS[scan_id]

@router.get("/history")
async def get_scan_history():
    """
    Get a list of all recent scans.
    """
    # Sort by created_at desc
    sorted_scans = sorted(
        list(SCAN_RESULTS.values()), 
        key=lambda x: x["created_at"], 
        reverse=True
    )
    return sorted_scans
