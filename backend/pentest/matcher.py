import logging
import re
from typing import List, Optional, Dict
import sys
from pathlib import Path

# Add backend to path for absolute imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from vuln_data.models import Vulnerability
from vuln_data.manager import VulnDataManager

logger = logging.getLogger(__name__)

class RiskScorer:
    """
    Calculates Aegis Risk Score (0.0 - 10.0) based on multiple signals.
    """
    @staticmethod
    def calculate(vuln: Vulnerability) -> float:
        # Start with CVSS or Default
        base = vuln.cvss_v3_score or 5.0
        
        metrics = []

        # 1. KEV Signal (Real World Impact)
        if vuln.known_exploited:
            # If validated exploit exists, it is critical regardless of complexity.
            # Boost to at least 9.0 (Critical)
            if base < 9.0:
                base = 9.0
            metrics.append("Known Exploited")

        # 2. Remote Code Execution (keyword boost)
        if vuln.description and "code execution" in vuln.description.lower():
             if base < 8.0:
                 base += 1.0
             metrics.append("RCE Potential")

        # Cap at 10.0
        final_score = min(base, 10.0)
        
        # Update level string
        level = "LOW"
        if final_score >= 9.0: level = "CRITICAL"
        elif final_score >= 7.0: level = "HIGH"
        elif final_score >= 4.0: level = "MEDIUM"
        
        # We don't mutate the vuln object here permanently, but return the calc
        return final_score

class VulnerabilityMatcher:
    def __init__(self):
        self.manager = VulnDataManager()
        self.manager.load_db()
        self.product_index: Dict[str, List[Vulnerability]] = {}
        self._build_index()

    def _build_index(self):
        """Indexes vulnerabilities by product name for fast lookup."""
        for vuln in self.manager.db.values():
            # Index by CPE product part
            # cpe:2.3:a:vendor:product:version...
            for cpe in vuln.affected_cpes:
                try:
                    parts = cpe.split(':')
                    if len(parts) >= 5:
                        product = parts[4]
                        self._add_to_index(product, vuln)
                except Exception:
                    pass
            
            # Index by CISA metadata if available?
            # (Currently we rely on CPEs from NVD/CISA sync)

    def _add_to_index(self, product: str, vuln: Vulnerability):
        if product not in self.product_index:
            self.product_index[product] = []
        # Dedupe
        if vuln not in self.product_index[product]:
            self.product_index[product].append(vuln)

    def match(self, service: str, version: str) -> List[Vulnerability]:
        """
        Matches a service (e.g. 'vsftpd', 'apache') and version to known vulns.
        """
        matches = []
        if not service:
            return []
            
        # Normalize service names typical in Nmap
        # nmap 'httpd' -> might be 'http_server' or 'apache'
        # nmap 'domain' -> 'bind'?
        # This mapping is naive; a real system uses 'cpe' output from Nmap directly.
        # But Nmap XML output *does* provide CPEs if -sV is used!
        # ParseNmapXML in Step 358 extracts 'product' and 'version'.
        # It also has 'service' identifier.
        # Ideally we pass the CPE Nmap found.
        
        # Normalize service
        service_norm = service.lower().strip()
        
        # Strategy 1: Exact Match
        candidates = self.product_index.get(service_norm, [])
        
        # Strategy 2: Token Match (e.g. "Apache httpd" -> try "apache", "httpd")
        if not candidates:
            tokens = service_norm.split()
            for token in tokens:
                if token in self.product_index:
                    candidates.extend(self.product_index[token])
                    
        # Strategy 3: Substring/Fuzzy (Risky, but better than nothing for MVP)
        if not candidates:
             # e.g. "apache_server" isn't in index, but "apache" is.
             # If token matching failed, maybe the index key is a substring of service?
             # Skipping for now to avoid false positives.
             pass

        # Deduplicate candidates
        candidates = list({v.id: v for v in candidates}.values())
        
        for vuln in candidates:
            # Version Check
            if self._check_version(version, vuln.affected_cpes):
                matches.append(vuln)
                
        return matches

    def _check_version(self, target_version: str, cpes: List[str]) -> bool:
        """
        Checks if target_version is present in any of the CPE strings.
        Naive substring match for MVP.
        """
        if not target_version:
            return False # Conservative: if no version detected, don't flag (false positives bad)
            # Or maybe Flag as "Potential"? Plan said "Low Cost, Early Awareness".
            # False positives are "High Cost" (investigation time).
            # So Strict matching is better.
            
        for cpe in cpes:
            # cpe:2.3:a:vendor:product:version:update:edition:language...
            parts = cpe.split(":")
            if len(parts) >= 6:
                cpe_version = parts[5] # Index 5 is version
                
                # Wildcard match (if our DB has *, it affects all/unknown versions)
                if cpe_version == "*" or cpe_version == "":
                    return True
                    
                # Exact version match
                if cpe_version == target_version:
                    return True
                
            # Fallback for simpler string checks if split fails (legacy)
            if f":{target_version}:" in cpe or cpe.endswith(f":{target_version}"):
                return True
                
        return False
