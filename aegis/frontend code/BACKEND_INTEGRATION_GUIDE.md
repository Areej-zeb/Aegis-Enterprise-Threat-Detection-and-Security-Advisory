# Backend Integration Guide - Aegis IDS Dashboard

## Overview

This guide explains how to integrate the React dashboard with your existing FastAPI backend for real-time WebSocket alerts.

## Your Current Backend

**Location**: `backend/ids/serve/app.py`  
**Port**: 8000  
**Framework**: FastAPI + Uvicorn  
**WebSocket**: `backend/ids/serve/stream.py`

## WebSocket Endpoint Required

The React dashboard expects a WebSocket endpoint at:

```
ws://localhost:8000/ws/alerts
```

## Backend Implementation

### Option 1: Add to Existing FastAPI App

Add this to your `backend/ids/serve/app.py`:

```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from typing import List
import asyncio
import json
from datetime import datetime

app = FastAPI()

# Store active WebSocket connections
active_connections: List[WebSocket] = []

@app.websocket("/ws/alerts")
async def websocket_alerts(websocket: WebSocket):
    """
    WebSocket endpoint for streaming real-time alerts to the dashboard.
    Sends alerts as they are generated by the IDS engine.
    """
    await websocket.accept()
    active_connections.append(websocket)
    
    try:
        print(f"[WebSocket] Client connected. Total connections: {len(active_connections)}")
        
        # Keep connection alive and send alerts
        while True:
            # Wait for next alert from your IDS engine
            # This is a placeholder - integrate with your actual alert generation
            await asyncio.sleep(0.1)  # Small delay to prevent busy loop
            
    except WebSocketDisconnect:
        active_connections.remove(websocket)
        print(f"[WebSocket] Client disconnected. Total connections: {len(active_connections)}")
    except Exception as e:
        print(f"[WebSocket] Error: {e}")
        if websocket in active_connections:
            active_connections.remove(websocket)


async def broadcast_alert(alert: dict):
    """
    Broadcast an alert to all connected WebSocket clients.
    Call this function whenever your IDS generates a new alert.
    
    Args:
        alert: Alert dictionary matching the schema below
    """
    if not active_connections:
        return
    
    # Format alert for dashboard
    formatted_alert = {
        "id": alert.get("id", f"alert-{datetime.utcnow().timestamp()}"),
        "timestamp": alert.get("timestamp", datetime.utcnow().isoformat()),
        "attack_type": alert.get("attack_type", "Unknown"),
        "severity": alert.get("severity", "MEDIUM").upper(),
        "src_ip": alert.get("src_ip"),
        "dst_ip": alert.get("dst_ip"),
        "status": alert.get("status", "NEW").upper(),
        "score": alert.get("score", 0.0),
        "description": alert.get("description"),
        "tags": alert.get("tags", []),
        "meta": alert.get("meta", {}),
    }
    
    # Send to all connected clients
    disconnected = []
    for connection in active_connections:
        try:
            await connection.send_json(formatted_alert)
        except Exception as e:
            print(f"[WebSocket] Failed to send to client: {e}")
            disconnected.append(connection)
    
    # Remove disconnected clients
    for connection in disconnected:
        active_connections.remove(connection)
```

### Option 2: Demo Mode with Random Alerts

For testing, add this demo mode to your backend:

```python
import random
from datetime import datetime

@app.websocket("/ws/alerts")
async def websocket_alerts(websocket: WebSocket):
    """Demo mode: Generate random alerts for testing"""
    await websocket.accept()
    
    attack_types = [
        "DDoS_SYN_Flood",
        "Port_Scan",
        "Brute_Force_SSH",
        "SQL_Injection",
        "XSS_Attack",
        "DNS_Tunnel",
        "MITM_ARP_Spoofing",
    ]
    
    severities = ["LOW", "MEDIUM", "HIGH", "CRITICAL"]
    
    try:
        print("[WebSocket] Client connected (Demo Mode)")
        
        while True:
            # Generate random alert
            alert = {
                "id": f"alert-{random.randint(1000, 9999)}",
                "timestamp": datetime.utcnow().isoformat(),
                "attack_type": random.choice(attack_types),
                "severity": random.choice(severities),
                "src_ip": f"192.168.{random.randint(1, 255)}.{random.randint(1, 254)}",
                "dst_ip": f"10.0.0.{random.randint(1, 254)}",
                "status": "NEW",
                "score": round(random.uniform(0.5, 0.99), 2),
                "description": "Suspicious network activity detected",
                "tags": ["demo", "auto-generated"],
                "meta": {
                    "model_name": "xgb_baseline",
                    "confidence": round(random.uniform(0.7, 0.95), 2),
                }
            }
            
            await websocket.send_json(alert)
            
            # Random delay between 1-2.5 seconds
            await asyncio.sleep(random.uniform(1.0, 2.5))
            
    except WebSocketDisconnect:
        print("[WebSocket] Client disconnected")
```

## Integration with Your IDS Engine

### Where to Call `broadcast_alert()`

In your IDS detection pipeline, after generating an alert:

```python
# In your detection/analysis code
async def process_network_traffic(packet):
    # Your existing detection logic
    result = ml_model.predict(packet_features)
    
    if result.is_attack:
        alert = {
            "id": generate_alert_id(),
            "timestamp": datetime.utcnow().isoformat(),
            "attack_type": result.attack_type,
            "severity": calculate_severity(result.score),
            "src_ip": packet.src_ip,
            "dst_ip": packet.dst_ip,
            "status": "NEW",
            "score": result.score,
            "description": f"Detected {result.attack_type} attack",
            "tags": ["live", "ml-detected"],
            "meta": {
                "model_name": "xgb_baseline",
                "confidence": result.confidence,
                "protocol": packet.protocol,
            }
        }
        
        # Broadcast to WebSocket clients
        await broadcast_alert(alert)
        
        # Your existing alert storage/processing
        save_alert_to_db(alert)
```

## Alert Schema

The dashboard expects alerts in this format:

```typescript
{
  id: string;                    // Unique alert identifier
  timestamp: string;             // ISO 8601 format
  attack_type: string;           // e.g., "DDoS_SYN_Flood"
  severity: "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
  src_ip?: string;               // Source IP address
  dst_ip?: string;               // Destination IP address
  status: "NEW" | "ACKNOWLEDGED" | "SUPPRESSED" | "RESOLVED";
  score?: number;                // Confidence score (0-1)
  description?: string;          // Human-readable description
  tags?: string[];               // Optional tags
  meta?: {                       // Optional metadata
    model_name?: string;
    confidence?: number;
    protocol?: string;
    [key: string]: any;
  };
}
```

## Testing the Integration

### 1. Start Your Backend

```bash
# From project root
cd Aegis-Enterprise-Threat-Detection-and-Security-Advisory
./start-aegis.sh

# Or manually:
source venv/bin/activate
export PYTHONPATH=$(pwd)
uvicorn backend.ids.serve.app:app --reload --host 0.0.0.0 --port 8000
```

### 2. Start the React Dashboard

```bash
# From project root
cd aegis-dashboard
npm install
npm run dev
```

### 3. Test WebSocket Connection

1. Open browser to `http://localhost:5173`
2. Navigate to "Live Alerts" page
3. Enable "WebSocket" toggle
4. Check connection status indicator:
   - ðŸŸ¢ "Live" = Connected successfully
   - ðŸ”´ "Disconnected" = Connection failed

### 4. Verify Alerts

- New alerts should appear instantly (no 5-second delay)
- Toast notifications should pop up for each alert
- Alert list should update in real-time

## Debugging

### Check WebSocket Endpoint

```bash
# Test if WebSocket endpoint exists
curl -i -N -H "Connection: Upgrade" \
     -H "Upgrade: websocket" \
     -H "Sec-WebSocket-Version: 13" \
     -H "Sec-WebSocket-Key: test" \
     http://localhost:8000/ws/alerts
```

Expected response: `101 Switching Protocols`

### Browser Console

Open browser DevTools (F12) and check:

```javascript
// Should see these logs:
[WebSocket] Connecting to: ws://localhost:8000/ws/alerts
[WebSocket] Connected
[WebSocket] Received alert: {...}
```

### Backend Logs

Your FastAPI backend should show:

```
[WebSocket] Client connected. Total connections: 1
INFO:     ('127.0.0.1', 54321) - "WebSocket /ws/alerts" [accepted]
```

## CORS Configuration

Ensure your FastAPI app allows WebSocket connections from the React app:

```python
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

## Production Deployment

### Use Secure WebSocket (WSS)

```python
# In production, use WSS with SSL/TLS
# Update frontend .env:
VITE_AEGIS_WS_BASE_URL=wss://your-domain.com
```

### Add Authentication

```python
from fastapi import WebSocket, Header, HTTPException

@app.websocket("/ws/alerts")
async def websocket_alerts(
    websocket: WebSocket,
    token: str = Header(None)
):
    # Verify token
    if not verify_token(token):
        await websocket.close(code=1008)  # Policy violation
        return
    
    await websocket.accept()
    # ... rest of implementation
```

### Monitor Connections

```python
import time

connection_metrics = {
    "total_connections": 0,
    "active_connections": 0,
    "total_alerts_sent": 0,
    "start_time": time.time(),
}

@app.get("/api/v1/websocket/metrics")
async def get_websocket_metrics():
    return {
        **connection_metrics,
        "uptime_seconds": time.time() - connection_metrics["start_time"],
    }
```

## Troubleshooting

### WebSocket Won't Connect

1. **Check backend is running**: `curl http://localhost:8000/docs`
2. **Verify endpoint exists**: Check FastAPI docs at `/docs`
3. **Check CORS**: Ensure localhost:5173 is allowed
4. **Check firewall**: Ensure port 8000 is open

### Alerts Not Appearing

1. **Check backend logs**: Look for WebSocket messages
2. **Verify alert format**: Must match schema above
3. **Check browser console**: Look for parsing errors
4. **Test with demo mode**: Use random alert generator

### Connection Drops

1. **Increase timeout**: Add keepalive pings
2. **Check network**: Verify stable connection
3. **Monitor backend**: Check for crashes/restarts

## Next Steps

1. âœ… Add WebSocket endpoint to your FastAPI app
2. âœ… Integrate `broadcast_alert()` with your IDS engine
3. âœ… Test with demo mode first
4. âœ… Deploy to production with WSS and authentication
5. âœ… Monitor connection metrics

## Support

For issues or questions:
- Check `WEBSOCKET_INTEGRATION.md` for detailed documentation
- Review `WEBSOCKET_IMPLEMENTATION_SUMMARY.md` for quick reference
- Open an issue on GitHub

---

**Your backend is ready!** Just add the WebSocket endpoint and start streaming alerts to the dashboard. ðŸš€
